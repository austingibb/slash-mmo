<!DOCTYPE html>
<html>

<head>
    <title>Slash Game</title>
</head>

<!--<script src="require/2.3.5/require.js"></script>-->
<!--<script src="socket.io/2.0.4/socket.io.js"></script>-->
<!--<script src="http://localhost:42069/socket.io/socket.io.js"></script>-->
<script src="http://98.202.130.238:42069/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-3.2.1.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.16/p5.js"></script>
<img id="dickbutt" src="https://botw-pd.s3.amazonaws.com/styles/logo-thumbnail/s3/082016/untitled-1_5.png?itok=GQSXV16J" style="display: none"/>

<body>
    <canvas id="game-canvas" onclick="canvasClicked(event)"></canvas>
</body>

<script>
    var p5 = {};

    /**
     * A class to describe a two or three dimensional vector, specifically
     * a Euclidean (also known as geometric) vector. A vector is an entity
     * that has both magnitude and direction. The datatype, however, stores
     * the components of the vector (x, y for 2D, and x, y, z for 3D). The magnitude
     * and direction can be accessed via the methods mag() and heading().
     * <br><br>
     * In many of the p5.js examples, you will see p5.Vector used to describe a
     * position, velocity, or acceleration. For example, if you consider a rectangle
     * moving across the screen, at any given instant it has a position (a vector
     * that points from the origin to its location), a velocity (the rate at which
     * the object's position changes per time unit, expressed as a vector), and
     * acceleration (the rate at which the object's velocity changes per time
     * unit, expressed as a vector).
     * <br><br>
     * Since vectors represent groupings of values, we cannot simply use
     * traditional addition/multiplication/etc. Instead, we'll need to do some
     * "vector" math, which is made easy by the methods inside the p5.Vector class.
     *
     * @class p5.Vector
     * @constructor
     * @param {Number} [x] x component of the vector
     * @param {Number} [y] y component of the vector
     * @param {Number} [z] z component of the vector
     * @example
     * <div>
     * <code>
     * var v1 = createVector(40, 50);
     * var v2 = createVector(40, 50);
     *
     * ellipse(v1.x, v1.y, 50, 50);
     * ellipse(v2.x, v2.y, 50, 50);
     * v1.add(v2);
     * ellipse(v1.x, v1.y, 50, 50);
     * </code>
     * </div>
     *
     * @alt
     * 2 white ellipses. One center-left the other bottom right and off canvas
     *
     */
    p5.Vector = function () {
        var x, y, z;
        x = arguments[0] || 0;
        y = arguments[1] || 0;
        z = arguments[2] || 0;
        /**
         * The x component of the vector
         * @property x {Number}
         */
        this.x = x;
        /**
         * The y component of the vector
         * @property y {Number}
         */
        this.y = y;
        /**
         * The z component of the vector
         * @property z {Number}
         */
        this.z = z;
        this.name = 'p5.Vector';   // for friendly debugger system
    };

    /**
     * Returns a string representation of a vector v by calling String(v)
     * or v.toString(). This method is useful for logging vectors in the
     * console.
     * @method  toString
     * @example
     * <div class = "norender"><code>
     * function setup() {
     *   var v = createVector(20,30);
     *   print(String(v)); // prints "p5.Vector Object : [20, 30, 0]"
     * }
     * </div></code>
     *
     */
    p5.Vector.prototype.toString = function p5VectorToString() {
        return 'p5.Vector Object : [' + this.x + ', ' + this.y + ', ' + this.z + ']';
    };

    /**
     * Sets the x, y, and z component of the vector using two or three separate
     * variables, the data from a p5.Vector, or the values from a float array.
     * @method set
     * @param {Number|p5.Vector|Array} [x] the x component of the vector or a
     *                                     p5.Vector or an Array
     * @param {Number}                 [y] the y component of the vector
     * @param {Number}                 [z] the z component of the vector
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * function setup() {
     *    var v = createVector(1, 2, 3);
     *    v.set(4,5,6); // Sets vector to [4, 5, 6]
     *
     *    var v1 = createVector(0, 0, 0);
     *    var arr = [1, 2, 3];
     *    v1.set(arr); // Sets vector to [1, 2, 3]
     * }
     * </code>
     * </div>
     */
    p5.Vector.prototype.set = function (x, y, z) {
        if (x instanceof p5.Vector) {
            this.x = x.x || 0;
            this.y = x.y || 0;
            this.z = x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x = x[0] || 0;
            this.y = x[1] || 0;
            this.z = x[2] || 0;
            return this;
        }
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        return this;
    };

    /**
     * Gets a copy of the vector, returns a p5.Vector object.
     *
     * @method copy
     * @return {p5.Vector} the copy of the p5.Vector object
     * @example
     * <div class="norender">
     * <code>
     * var v1 = createVector(1, 2, 3);
     * var v2 = v1.copy();
     * print(v1.x == v2.x && v1.y == v2.y && v1.z == v2.z);
     * // Prints "true"
     * </code>
     * </div>
     */
    p5.Vector.prototype.copy = function () {
        if (this.p5) {
            return new p5.Vector(this.p5, [this.x, this.y, this.z]);
        } else {
            return new p5.Vector(this.x, this.y, this.z);
        }
    };

    /**
     * Adds x, y, and z components to a vector, adds one vector to another, or
     * adds two independent vectors together. The version of the method that adds
     * two vectors together is a static method and returns a p5.Vector, the others
     * acts directly on the vector. See the examples for more context.
     *
     * @method add
     * @param  {Number|p5.Vector|Array} x   the x component of the vector to be
     *                                      added or a p5.Vector or an Array
     * @param  {Number}                 [y] the y component of the vector to be
     *                                      added
     * @param  {Number}                 [z] the z component of the vector to be
     *                                      added
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(1, 2, 3);
     * v.add(4,5,6);
     * // v's components are set to [5, 7, 9]
     * </code>
     * </div>
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(1, 2, 3);
     * var v2 = createVector(2, 3, 4);
     *
     * var v3 = p5.Vector.add(v1, v2);
     * // v3 has components [3, 5, 7]
     * </code>
     * </div>
     */
    p5.Vector.prototype.add = function (x, y, z) {
        if (x instanceof p5.Vector) {
            this.x += x.x || 0;
            this.y += x.y || 0;
            this.z += x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x += x[0] || 0;
            this.y += x[1] || 0;
            this.z += x[2] || 0;
            return this;
        }
        this.x += x || 0;
        this.y += y || 0;
        this.z += z || 0;
        return this;
    };

    /**
     * Subtracts x, y, and z components from a vector, subtracts one vector from
     * another, or subtracts two independent vectors. The version of the method
     * that subtracts two vectors is a static method and returns a p5.Vector, the
     * other acts directly on the vector. See the examples for more context.
     *
     * @method sub
     * @param  {Number|p5.Vector|Array} x   the x component of the vector or a
     *                                      p5.Vector or an Array
     * @param  {Number}                 [y] the y component of the vector
     * @param  {Number}                 [z] the z component of the vector
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(4, 5, 6);
     * v.sub(1, 1, 1);
     * // v's components are set to [3, 4, 5]
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(2, 3, 4);
     * var v2 = createVector(1, 2, 3);
     *
     * var v3 = p5.Vector.sub(v1, v2);
     * // v3 has components [1, 1, 1]
     * </code>
     * </div>
     */
    p5.Vector.prototype.sub = function (x, y, z) {
        if (x instanceof p5.Vector) {
            this.x -= x.x || 0;
            this.y -= x.y || 0;
            this.z -= x.z || 0;
            return this;
        }
        if (x instanceof Array) {
            this.x -= x[0] || 0;
            this.y -= x[1] || 0;
            this.z -= x[2] || 0;
            return this;
        }
        this.x -= x || 0;
        this.y -= y || 0;
        this.z -= z || 0;
        return this;
    };

    /**
     * Multiply the vector by a scalar. The static version of this method
     * creates a new p5.Vector while the non static version acts on the vector
     * directly. See the examples for more context.
     *
     * @method mult
     * @param  {Number}    n the number to multiply with the vector
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(1, 2, 3);
     * v.mult(2);
     * // v's components are set to [2, 4, 6]
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(1, 2, 3);
     * var v2 = p5.Vector.mult(v1, 2);
     * // v2 has components [2, 4, 6]
     * </code>
     * </div>
     */
    p5.Vector.prototype.mult = function (n) {
        this.x *= n || 0;
        this.y *= n || 0;
        this.z *= n || 0;
        return this;
    };

    /**
     * Divide the vector by a scalar. The static version of this method creates a
     * new p5.Vector while the non static version acts on the vector directly.
     * See the examples for more context.
     *
     * @method div
     * @param  {number}    n the number to divide the vector by
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(6, 4, 2);
     * v.div(2); //v's components are set to [3, 2, 1]
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * // Static method
     * var v1  = createVector(6, 4, 2);
     * var v2 = p5.Vector.div(v, 2);
     * // v2 has components [3, 2, 1]
     * </code>
     * </div>
     */
    p5.Vector.prototype.div = function (n) {
        this.x /= n;
        this.y /= n;
        this.z /= n;
        return this;
    };

    /**
     * Calculates the magnitude (length) of the vector and returns the result as
     * a float (this is simply the equation sqrt(x*x + y*y + z*z).)
     *
     * @method mag
     * @return {Number} magnitude of the vector
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(20.0, 30.0, 40.0);
     * var m = v.mag();
     * print(m); // Prints "53.85164807134504"
     * </code>
     * </div>
     */
    p5.Vector.prototype.mag = function () {
        return Math.sqrt(this.magSq());
    };

    /**
     * Calculates the squared magnitude of the vector and returns the result
     * as a float (this is simply the equation <em>(x*x + y*y + z*z)</em>.)
     * Faster if the real length is not required in the
     * case of comparing vectors, etc.
     *
     * @method magSq
     * @return {number} squared magnitude of the vector
     * @example
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(6, 4, 2);
     * print(v1.magSq()); // Prints "56"
     * </code>
     * </div>
     */
    p5.Vector.prototype.magSq = function () {
        var x = this.x, y = this.y, z = this.z;
        return (x * x + y * y + z * z);
    };

    /**
     * Calculates the dot product of two vectors. The version of the method
     * that computes the dot product of two independent vectors is a static
     * method. See the examples for more context.
     *
     *
     * @method dot
     * @param  {Number|p5.Vector} x   x component of the vector or a p5.Vector
     * @param  {Number}           [y] y component of the vector
     * @param  {Number}           [z] z component of the vector
     * @return {Number}                 the dot product
     *
     * @example
     * <div class="norender">
     * <code>
     * var v1 = createVector(1, 2, 3);
     * var v2 = createVector(2, 3, 4);
     *
     * print(v1.dot(v2)); // Prints "20"
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * //Static method
     * var v1 = createVector(1, 2, 3);
     * var v2 = createVector(3, 2, 1);
     * print (p5.Vector.dot(v1, v2)); // Prints "10"
     * </code>
     * </div>
     */
    p5.Vector.prototype.dot = function (x, y, z) {
        if (x instanceof p5.Vector) {
            return this.dot(x.x, x.y, x.z);
        }
        return this.x * (x || 0) +
            this.y * (y || 0) +
            this.z * (z || 0);
    };

    /**
     * Calculates and returns a vector composed of the cross product between
     * two vectors. Both the static and non static methods return a new p5.Vector.
     * See the examples for more context.
     *
     * @method cross
     * @param  {p5.Vector} v p5.Vector to be crossed
     * @return {p5.Vector}   p5.Vector composed of cross product
     * @example
     * <div class="norender">
     * <code>
     * var v1 = createVector(1, 2, 3);
     * var v2 = createVector(1, 2, 3);
     *
     * v1.cross(v2); // v's components are [0, 0, 0]
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(1, 0, 0);
     * var v2 = createVector(0, 1, 0);
     *
     * var crossProduct = p5.Vector.cross(v1, v2);
     * // crossProduct has components [0, 0, 1]
     * </code>
     * </div>
     */
    p5.Vector.prototype.cross = function (v) {
        var x = this.y * v.z - this.z * v.y;
        var y = this.z * v.x - this.x * v.z;
        var z = this.x * v.y - this.y * v.x;
        if (this.p5) {
            return new p5.Vector(this.p5, [x, y, z]);
        } else {
            return new p5.Vector(x, y, z);
        }
    };

    /**
     * Calculates the Euclidean distance between two points (considering a
     * point as a vector object).
     *
     * @method dist
     * @param  {p5.Vector} v the x, y, and z coordinates of a p5.Vector
     * @return {Number}      the distance
     * @example
     * <div class="norender">
     * <code>
     * var v1 = createVector(1, 0, 0);
     * var v2 = createVector(0, 1, 0);
     *
     * var distance = v1.dist(v2); // distance is 1.4142...
     * </code>
     * </div>
     * <div class="norender">
     * <code>
     * // Static method
     * var v1 = createVector(1, 0, 0);
     * var v2 = createVector(0, 1, 0);
     *
     * var distance = p5.Vector.dist(v1,v2);
     * // distance is 1.4142...
     * </code>
     * </div>
     */
    p5.Vector.prototype.dist = function (v) {
        var d = v.copy().sub(this);
        return d.mag();
    };

    /**
     * Normalize the vector to length 1 (make it a unit vector).
     *
     * @method normalize
     * @return {p5.Vector} normalized p5.Vector
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(10, 20, 2);
     * // v has components [10.0, 20.0, 2.0]
     * v.normalize();
     * // v's components are set to
     * // [0.4454354, 0.8908708, 0.089087084]
     * </code>
     * </div>
     *
     */
    p5.Vector.prototype.normalize = function () {
        return this.mag() === 0 ? this : this.div(this.mag());
    };

    /**
     * Limit the magnitude of this vector to the value used for the <b>max</b>
     * parameter.
     *
     * @method limit
     * @param  {Number}    max the maximum magnitude for the vector
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(10, 20, 2);
     * // v has components [10.0, 20.0, 2.0]
     * v.limit(5);
     * // v's components are set to
     * // [2.2271771, 4.4543543, 0.4454354]
     * </code>
     * </div>
     */
    p5.Vector.prototype.limit = function (max) {
        var mSq = this.magSq();
        if (mSq > max * max) {
            this.div(Math.sqrt(mSq)); //normalize it
            this.mult(max);
        }
        return this;
    };

    /**
     * Set the magnitude of this vector to the value used for the <b>len</b>
     * parameter.
     *
     * @method setMag
     * @param  {number}    len the new length for this vector
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(10, 20, 2);
     * // v has components [10.0, 20.0, 2.0]
     * v.setMag(10);
     * // v's components are set to [6.0, 8.0, 0.0]
     * </code>
     * </div>
     */
    p5.Vector.prototype.setMag = function (n) {
        return this.normalize().mult(n);
    };

    /**
     * Calculate the angle of rotation for this vector (only 2D vectors)
     *
     * @method heading
     * @return {Number} the angle of rotation
     * @example
     * <div class = "norender"><code>
     * function setup() {
     *   var v1 = createVector(30,50);
     *   print(v1.heading()); // 1.0303768265243125
     *
     *   var v1 = createVector(40,50);
     *   print(v1.heading()); // 0.8960553845713439
     *
     *   var v1 = createVector(30,70);
     *   print(v1.heading()); // 1.1659045405098132
     * }
     * </div></code>
     */
    p5.Vector.prototype.heading = function () {
        var h = Math.atan2(this.y, this.x);
        if (this.p5) {
            if (this.p5._angleMode === constants.RADIANS) {
                return h;
            } else {
                return polarGeometry.radiansToDegrees(h);
            }
        } else {
            return h;
        }
    };

    /**
     * Rotate the vector by an angle (only 2D vectors), magnitude remains the
     * same
     *
     * @method rotate
     * @param  {number}    angle the angle of rotation
     * @chainable
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(10.0, 20.0);
     * // v has components [10.0, 20.0, 0.0]
     * v.rotate(HALF_PI);
     * // v's components are set to [-20.0, 9.999999, 0.0]
     * </code>
     * </div>
     */
    p5.Vector.prototype.rotate = function (a) {
        var newHeading = a;
        var mag = this.mag();
        this.x = Math.cos(newHeading) * mag;
        this.y = Math.sin(newHeading) * mag;
        return this;
    };

    /**
     * Calculates and returns the angle (in radians) between two vectors.
     * @method angleBetween
     * @param  {p5.Vector}    the x, y, and z components of a p5.Vector
     * @return {Number}       the angle between (in radians)
     * @example
     * <div class="norender">
     * <code>
     * var v1 = createVector(1, 0, 0);
     * var v2 = createVector(0, 1, 0);
     *
     * var angle = v1.angleBetween(v2);
     * // angle is PI/2
     * </code>
     * </div>
     */
    p5.Vector.prototype.angleBetween = function (v) {
        var dotmagmag = this.dot(v) / (this.mag() * v.mag());
        // Mathematically speaking: the dotmagmag variable will be between -1 and 1
        // inclusive. Practically though it could be slightly outside this range due
        // to floating-point rounding issues. This can make Math.acos return NaN.
        //
        // Solution: we'll clamp the value to the -1,1 range
        var angle = Math.acos(Math.min(1, Math.max(-1, dotmagmag)));
        if (this.p5) {
            if (this.p5._angleMode === constants.DEGREES) {
                angle = polarGeometry.radiansToDegrees(angle);
            }
        }
        return angle;
    };

    /**
     * Linear interpolate the vector to another vector
     *
     * @method lerp
     * @param  {p5.Vector} x   the x component
     * @param  {p5.Vector} y   the y component
     * @param  {p5.Vector} z   the z component
     * @param  {Number}    amt the amount of interpolation; some value between 0.0
     *                         (old vector) and 1.0 (new vector). 0.9 is very near
     *                         the new vector. 0.5 is halfway in between.
     * @chainable
     */
    /**
     * @method lerp
     * @param  {p5.Vector} v   the p5.Vector to lerp to
     * @param  {Number}    amt
     * @chainable
     *
     * @example
     * <div class="norender">
     * <code>
     * var v = createVector(1, 1, 0);
     *
     * v.lerp(3, 3, 0, 0.5); // v now has components [2,2,0]
     * </code>
     * </div>
     *
     * <div class="norender">
     * <code>
     * var v1 = createVector(0, 0, 0);
     * var v2 = createVector(100, 100, 0);
     *
     * var v3 = p5.Vector.lerp(v1, v2, 0.5);
     * // v3 has components [50,50,0]
     * </code>
     * </div>
     */
    p5.Vector.prototype.lerp = function (x, y, z, amt) {
        if (x instanceof p5.Vector) {
            return this.lerp(x.x, x.y, x.z, y);
        }
        this.x += (x - this.x) * amt || 0;
        this.y += (y - this.y) * amt || 0;
        this.z += (z - this.z) * amt || 0;
        return this;
    };

    /**
     * Return a representation of this vector as a float array. This is only
     * for temporary use. If used in any other fashion, the contents should be
     * copied by using the <b>p5.Vector.copy()</b> method to copy into your own
     * array.
     *
     * @method array
     * @return {Number[]} an Array with the 3 values
     * @example
     * <div class = "norender"><code>
     * function setup() {
     *   var v = createVector(20,30);
     *   print(v.array()); // Prints : Array [20, 30, 0]
     * }
     * </div></code>
     * <div class="norender">
     * <code>
     * var v = createVector(10.0, 20.0, 30.0);
     * var f = v.array();
     * print(f[0]); // Prints "10.0"
     * print(f[1]); // Prints "20.0"
     * print(f[2]); // Prints "30.0"
     * </code>
     * </div>
     */
    p5.Vector.prototype.array = function () {
        return [this.x || 0, this.y || 0, this.z || 0];
    };

    /**
     * Equality check against a p5.Vector
     *
     * @method equals
     * @param {Number|p5.Vector|Array} [x] the x component of the vector or a
     *                                     p5.Vector or an Array
     * @param {Number}                 [y] the y component of the vector
     * @param {Number}                 [z] the z component of the vector
     * @return {Boolean} whether the vectors are equals
     * @example
     * <div class = "norender"><code>
     * v1 = createVector(5,10,20);
     * v2 = createVector(5,10,20);
     * v3 = createVector(13,10,19);
     *
     * print(v1.equals(v2.x,v2.y,v2.z)); // true
     * print(v1.equals(v3.x,v3.y,v3.z)); // false
     * </div></code>
     * <div class="norender">
     * <code>
     * var v1 = createVector(10.0, 20.0, 30.0);
     * var v2 = createVector(10.0, 20.0, 30.0);
     * var v3 = createVector(0.0, 0.0, 0.0);
     * print (v1.equals(v2)) // true
     * print (v1.equals(v3)) // false
     * </code>
     * </div>
     */
    p5.Vector.prototype.equals = function (x, y, z) {
        var a, b, c;
        if (x instanceof p5.Vector) {
            a = x.x || 0;
            b = x.y || 0;
            c = x.z || 0;
        } else if (x instanceof Array) {
            a = x[0] || 0;
            b = x[1] || 0;
            c = x[2] || 0;
        } else {
            a = x || 0;
            b = y || 0;
            c = z || 0;
        }
        return this.x === a && this.y === b && this.z === c;
    };


    // Static Methods


    /**
     * Make a new 2D unit vector from an angle
     *
     * @method fromAngle
     * @static
     * @param {Number}     angle the desired angle
     * @return {p5.Vector}       the new p5.Vector object
     * @example
     * <div>
     * <code>
     * function draw() {
     *   background (200);
     *
     *   // Create a variable, proportional to the mouseX,
     *   // varying from 0-360, to represent an angle in degrees.
     *   angleMode(DEGREES);
     *   var myDegrees = map(mouseX, 0,width, 0,360);
     *
     *   // Display that variable in an onscreen text.
     *   // (Note the nfc() function to truncate additional decimal places,
     *   // and the "\xB0" character for the degree symbol.)
     *   var readout = "angle = " + nfc(myDegrees,1,1) + "\xB0"
     *   noStroke();
     *   fill (0);
     *   text (readout, 5, 15);
     *
     *   // Create a p5.Vector using the fromAngle function,
     *   // and extract its x and y components.
     *   var v = p5.Vector.fromAngle(radians(myDegrees));
     *   var vx = v.x;
     *   var vy = v.y;
     *
     *   push();
     *   translate (width/2, height/2);
     *   noFill();
     *   stroke (150);
     *   line (0,0, 30,0);
     *   stroke (0);
     *   line (0,0, 30*vx, 30*vy);
     *   pop()
     * }
     * </code>
     * </div>
     */
    p5.Vector.fromAngle = function (angle) {
        if (this.p5) {
            if (this.p5._angleMode === constants.DEGREES) {
                angle = polarGeometry.degreesToRadians(angle);
            }
        }
        if (this.p5) {
            return new p5.Vector(this.p5, [Math.cos(angle), Math.sin(angle), 0]);
        } else {
            return new p5.Vector(Math.cos(angle), Math.sin(angle), 0);
        }
    };

    /**
     * Make a new 2D unit vector from a random angle
     *
     * @method random2D
     * @static
     * @return {p5.Vector} the new p5.Vector object
     * @example
     * <div class="norender">
     * <code>
     * var v = p5.Vector.random2D();
     * // May make v's attributes something like:
     * // [0.61554617, -0.51195765, 0.0] or
     * // [-0.4695841, -0.14366731, 0.0] or
     * // [0.6091097, -0.22805278, 0.0]
     * </code>
     * </div>
     */
    p5.Vector.random2D = function () {
        var angle;
        // A lot of nonsense to determine if we know about a
        // p5 sketch and whether we should make a random angle in degrees or radians
        if (this.p5) {
            if (this.p5._angleMode === constants.DEGREES) {
                angle = this.p5.random(360);
            } else {
                angle = this.p5.random(constants.TWO_PI);
            }
        } else {
            angle = Math.random() * Math.PI * 2;
        }
        return this.fromAngle(angle);
    };

    /**
     * Make a new random 3D unit vector.
     *
     * @method random3D
     * @static
     * @return {p5.Vector} the new p5.Vector object
     * @example
     * <div class="norender">
     * <code>
     * var v = p5.Vector.random3D();
     * // May make v's attributes something like:
     * // [0.61554617, -0.51195765, 0.599168] or
     * // [-0.4695841, -0.14366731, -0.8711202] or
     * // [0.6091097, -0.22805278, -0.7595902]
     * </code>
     * </div>
     */
    p5.Vector.random3D = function () {
        var angle, vz;
        // If we know about p5
        if (this.p5) {
            angle = this.p5.random(0, constants.TWO_PI);
            vz = this.p5.random(-1, 1);
        } else {
            angle = Math.random() * Math.PI * 2;
            vz = Math.random() * 2 - 1;
        }
        var vx = Math.sqrt(1 - vz * vz) * Math.cos(angle);
        var vy = Math.sqrt(1 - vz * vz) * Math.sin(angle);
        if (this.p5) {
            return new p5.Vector(this.p5, [vx, vy, vz]);
        } else {
            return new p5.Vector(vx, vy, vz);
        }
    };

    // Adds two vectors together and returns a new one.
    /**
     * @method add
     * @static
     * @param  {p5.Vector} v1 a p5.Vector to add
     * @param  {p5.Vector} v2 a p5.Vector to add
     * @param  {p5.Vector} target the vector to receive the result
     */
    /**
     * @method add
     * @static
     * @param  {p5.Vector} v1
     * @param  {p5.Vector} v2
     * @return {p5.Vector} the resulting p5.Vector
     *
     */

    p5.Vector.add = function (v1, v2, target) {
        if (!target) {
            target = v1.copy();
        } else {
            target.set(v1);
        }
        target.add(v2);
        return target;
    };

    /*
     * Subtracts one p5.Vector from another and returns a new one.  The second
     * vector (v2) is subtracted from the first (v1), resulting in v1-v2.
     */
    /**
     * @method sub
     * @static
     * @param  {p5.Vector} v1 a p5.Vector to subtract from
     * @param  {p5.Vector} v2 a p5.Vector to subtract
     * @param  {p5.Vector} target if undefined a new vector will be created
     */
    /**
     * @method sub
     * @static
     * @param  {p5.Vector} v1
     * @param  {p5.Vector} v2
     * @return {p5.Vector} the resulting p5.Vector
     */

    p5.Vector.sub = function (v1, v2, target) {
        if (!target) {
            target = v1.copy();
        } else {
            target.set(v1);
        }
        target.sub(v2);
        return target;
    };


    /**
     * Multiplies a vector by a scalar and returns a new vector.
     */
    /**
     * @method mult
     * @static
     * @param  {p5.Vector} v the vector to multiply
     * @param  {Number}  n
     * @param  {p5.Vector} target if undefined a new vector will be created
     */
    /**
     * @method mult
     * @static
     * @param  {p5.Vector} v
     * @param  {Number}  n
     * @return {p5.Vector}  the resulting new p5.Vector
     */
    p5.Vector.mult = function (v, n, target) {
        if (!target) {
            target = v.copy();
        } else {
            target.set(v);
        }
        target.mult(n);
        return target;
    };

    /**
     * Divides a vector by a scalar and returns a new vector.
     */
    /**
     * @method div
     * @static
     * @param  {p5.Vector} v the vector to divide
     * @param  {Number}  n
     * @param  {p5.Vector} target if undefined a new vector will be created
     */
    /**
     * @method div
     * @static
     * @param  {p5.Vector} v
     * @param  {Number}  n
     * @return {p5.Vector} the resulting new p5.Vector
     */
    p5.Vector.div = function (v, n, target) {
        if (!target) {
            target = v.copy();
        } else {
            target.set(v);
        }
        target.div(n);
        return target;
    };


    /**
     * Calculates the dot product of two vectors.
     */
    /**
     * @method dot
     * @static
     * @param  {p5.Vector} v1 the first p5.Vector
     * @param  {p5.Vector} v2 the second p5.Vector
     * @return {Number}     the dot product
     */
    p5.Vector.dot = function (v1, v2) {
        return v1.dot(v2);
    };

    /**
     * Calculates the cross product of two vectors.
     */
    /**
     * @method cross
     * @static
     * @param  {p5.Vector} v1 the first p5.Vector
     * @param  {p5.Vector} v2 the second p5.Vector
     * @return {Number}     the cross product
     */
    p5.Vector.cross = function (v1, v2) {
        return v1.cross(v2);
    };

    /**
     * Calculates the Euclidean distance between two points (considering a
     * point as a vector object).
     */
    /**
     * @method dist
     * @static
     * @param  {p5.Vector} v1 the first p5.Vector
     * @param  {p5.Vector} v2 the second p5.Vector
     * @return {Number}     the distance
     */
    p5.Vector.dist = function (v1, v2) {
        return v1.dist(v2);
    };

    /**
     * Linear interpolate a vector to another vector and return the result as a
     * new vector.
     */
    /**
     * @method lerp
     * @static
     * @param {p5.Vector} v1
     * @param {p5.Vector} v2
     * @param {Number} amt
     * @param {p5.Vector} target if undefined a new vector will be created
     */
    /**
     * @method lerp
     * @static
     * @param {p5.Vector} v1
     * @param {p5.Vector} v2
     * @param {Number} amt
     * @return {Number}      the lerped value
     */
    p5.Vector.lerp = function (v1, v2, amt, target) {
        if (!target) {
            target = v1.copy();
        } else {
            target.set(v1);
        }
        target.lerp(v2, amt);
        return target;
    };

    /**
     * @method mag
     * @param {p5.Vector} vecT the vector to return the magnitude of
     * @return {Number}        the magnitude of vecT
     * @static
     */
    p5.Vector.mag = function (vecT) {
        var x = vecT.x,
            y = vecT.y,
            z = vecT.z;
        var magSq = x * x + y * y + z * z;
        return Math.sqrt(magSq);
    };
</script>

<script>
    var Vector = p5.Vector;
    var vec = new Vector(1, 1);
    var food_colors = ["#011f4b", "#03396c", "#005b96", "#6497b1", "#b3cde0"];
    var player_colors = ["#966842", "#f44747", "#eedc31", "#7fdb6a"];

    var view_port_width = 15;
    var view_port_width_min = 15;
    var view_port_width_max = 40;
    var canvas_width = 1300;
    var canvas = document.getElementById('game-canvas');
    canvas.width = canvas_width;
    canvas.height = canvas_width;
    var ctx = canvas.getContext('2d');
    ctx.font = '20px serif';

    var players = {};
    var food_list = {};

    //var socket = io("http://localhost:42069");
    var socket = io("http://98.202.130.238:42069");
    var client_id = -1;
    var world_width = 0;
    var world_height = 0;
    socket.on('setupInfo', function (setup_object) {
        players = {};
        food_list = {};

        client_id = setup_object.client_id;
        world_width = setup_object.world_width;
        world_height = setup_object.world_height;
        console.log(client_id);
    });

    socket.on('worldRepresentation', function (world_representation) {
        for (var player_id in world_representation.player_list) {
            addOrUpdatePlayer(world_representation.player_list[player_id]);
        }

        for (var food_id in world_representation.food_list) {
            addOrUpdateFood(world_representation.food_list[food_id]);
        }

        if (players[client_id]) {
            drawAll();
        }
    });

    socket.on('removePlayer', function (playerId) {
        if (players[playerId]) {
            delete players[playerId];
        }
    });

    socket.on('removeFood', function (food_ids) {
        food_ids.forEach(function (food_id) {
            if (food_list[food_id]) {
                delete food_list[food_id];
            }
        });
    });

    function drawAll() {
        if (players != undefined && players[client_id]) {
            view_port_width = map(players[client_id].slash_radius, 2, 10, view_port_width_min, view_port_width_max);
        }

        if (canvas.getContext) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            var x1 = toCanvasCoordX(0);
            var y1 = toCanvasCoordY(0);
            var x2 = toCanvasCoordX(world_width);
            var y2 = toCanvasCoordY(world_height);
            ctx.beginPath();
            ctx.rect(x1, y1, x2 - x1, y2 - y1);
            ctx.strokeStyle = "#4c516d";
            ctx.lineWidth = 10;
            ctx.stroke();

            for (var food_id in food_list) {
                var food = food_list[food_id];
                drawCircle(ctx, toCanvasCoordX(food.x), toCanvasCoordY(food.y), getPixelsPerWorldUnit() * food.radius, food_colors[food_id % food_colors.length]);
            }

            for (var player_id in players) {
                var player = players[player_id];
                if (player.state < 5) {
                    //drawCircle(ctx, toCanvasCoordX(player.tail_x), toCanvasCoordY(player.tail_y), 5);
                    //drawCircle(ctx, toCanvasCoordX(player.head_x), toCanvasCoordY(player.head_y), 5);
                    //ctx.beginPath();
                    //ctx.moveTo(toCanvasCoordX(player.tail_x), toCanvasCoordY(player.tail_y));
                    //ctx.lineTo(toCanvasCoordX(player.head_x), toCanvasCoordY(player.head_y));
                    //ctx.stroke();

                    var point_one = new Vector(toCanvasCoordX(player.tail_x), toCanvasCoordY(player.tail_y));
                    var point_two = new Vector(toCanvasCoordX(player.head_x), toCanvasCoordY(player.head_y));
                    var ppwu = getPixelsPerWorldUnit();
                    var radius_one = ppwu * player.tail_radius;
                    var radius_two = ppwu * player.head_radius;
                    drawConnectedCircles(point_one, point_two, radius_one, radius_two, player_colors[player_id % player_colors.length]);

                    //drawEmptyCircle(ctx, toCanvasCoordX(player.head_x), toCanvasCoordY(player.head_y), getPixelsPerWorldUnit() * player.slash_radius);
                }
            }

            if (players[client_id]) {
                ctx.fillText("Player pos: (" + players[client_id].head_x + ", " + players[client_id].head_y + ")", 20, 20);
                ctx.fillText("Points: " + players[client_id].points, 20, 40);
            }
        }
    }

    function drawCircle(ctx, x, y, r, style) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, 2 * Math.PI);
        ctx.fillStyle = (style != undefined ? style : '#000000');
        ctx.fill();
    }

    //function drawEmptyCircle(ctx, x, y, r) {
    //    ctx.beginPath();
    //    ctx.arc(x, y, r, 0, 2 * Math.PI);
    //    ctx.stroke();
    //}

    function addOrUpdateFood(food_representation) {
        var food;
        if (food_list[food_representation.id]) {
            food = food_list[food_representation.id];
        }
        else {
            food = {};
        }

        for (var attrname in food_representation) { food[attrname] = food_representation[attrname] }

        food_list[food_representation.id] = food;
    }

    function addOrUpdatePlayer(player_representation) {
        var player;
        if (players[player_representation.id]) {
            player = players[player_representation.id];
        }
        else {
            player = {};
        }

        for (var attrname in player_representation) { player[attrname] = player_representation[attrname] }

        players[player_representation.id] = player;
    }

    function toCanvasCoordX(world_x) {
        var player = players[client_id];
        var player_relative_world_x = world_x - player.head_x + view_port_width / 2;
        var pixels_per_world_unit = canvas_width / view_port_width;
        return pixels_per_world_unit * player_relative_world_x;
    }

    function toCanvasCoordY(world_y) {
        var player = players[client_id];
        var player_relative_world_y = world_y - player.head_y + view_port_width / 2;
        var pixels_per_world_unit = canvas_width / view_port_width;
        return pixels_per_world_unit * player_relative_world_y;
    }

    function getPixelsPerWorldUnit() {
        var player = players[client_id];
        return canvas_width / view_port_width;
    }

    function toWorldCoordX(canvas_x) {
        var player = players[client_id];
        var pixels_per_world_unit = canvas_width / view_port_width;
        var player_relative_world_x = canvas_x / pixels_per_world_unit;
        return player_relative_world_x + player.head_x - view_port_width / 2;
    }

    function toWorldCoordY(canvas_y) {
        var player = players[client_id];
        var pixels_per_world_unit = canvas_width / view_port_width;
        var player_relative_world_y = canvas_y / pixels_per_world_unit;
        return player_relative_world_y + player.head_y - view_port_width / 2;
    }

    function canvasClicked(event) {
        var click_x = event.offsetX;
        var click_y = event.offsetY;
        var position = {};
        position.x = toWorldCoordX(click_x);
        position.y = toWorldCoordY(click_y);
        socket.emit('slashto', position);
    }

    // the bullshit I didt to hack apart p5. Possibly just rebuild this client in p5
    function clamp(val, min, max) {
        if (val < min) {
            val = min;
        }
        else if (val > max) {
            val = max;
        }

        return val;
    }

    function map(val, in_min, in_max, out_min, out_max) {
        return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    }

    function rotateVector(vec, angle) {
        var x = vec.x,
            y = vec.y,
            radians = (Math.PI / 180) * angle,
            cos = Math.cos(radians),
            sin = Math.sin(radians),
            nx = (cos * (x)) + (sin * (y)),
            ny = (cos * (y)) - (sin * (x));

        vec.x = nx;
        vec.y = ny;
    }

    function drawConnectedCircles(point_one, point_two, radius_one, radius_two, style) {
        var diff_vec = point_two.copy();
        diff_vec.sub(point_one);
        var diff_vec_radius_one = diff_vec.copy();
        diff_vec_radius_one.normalize();
        diff_vec_radius_one.mult(radius_one);
        var angle_shift = 360 / 8;
        var points = [];
        for (i = 0; i < 8; i++) {
            var angle = i * angle_shift + 0.5 * angle_shift;
            var vector = diff_vec_radius_one.copy();
            rotateVector(vector, angle);
            vector.add(point_one);
            //if (draw_points) {
            //    drawCircle(ctx, vector, 2 * i + 1);
            //}
            points.push(vector);
        }

        var diff_vec_radius_two = diff_vec.copy();
        diff_vec_radius_two.mult(-1);
        diff_vec_radius_two.normalize();
        diff_vec_radius_two.mult(radius_two);

        for (i = 0; i < 8; i++) {
            var angle = i * angle_shift + 0.5 * angle_shift;
            var vector = diff_vec_radius_two.copy();
            rotateVector(vector, angle);
            vector.add(point_two);
            points.push(vector);
            //if (draw_points) {
            //    drawCircle(ctx, vector, 2 * i + 1);
            //}
        }

        curveThroughPoints(points, style);
        drawCircle(ctx, point_one.x, point_one.y, radius_one, style);
    }

    function curveThroughPoints(points, style) {
        var midPoints = [];

        ctx.beginPath();
        var xc = (points[points.length - 1].x + points[0].x) / 2;
        var yc = (points[points.length - 1].y + points[0].y) / 2;
        midPoints.push(new Vector(xc, yc));
        ctx.moveTo(xc, yc);

        for (i = 0; i < points.length; i++) {
            i = limitWrap(i, points.length);
            var nextI = limitWrap(i + 1, points.length);
            xc = (points[i].x + points[nextI].x) / 2;
            yc = (points[i].y + points[nextI].y) / 2;
            midPoints.push(new Vector(xc, yc));
            ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }

        ctx.closePath();
        ctx.fillStyle = style;
        ctx.fill();

        //if (draw_points) {
        //    midPoints.forEach(function (vec) {
        //        drawCircle(ctx, vec, 2);
        //    });
        //}
    }

    function limitWrap(i, max) {
        if (i < 0) {
            i = max + i;
        } else if (i >= max) {
            i = i % max;
        }

        return i;
    }
</script>

</html>